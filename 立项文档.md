# 立项文档

## pp-store是什么？

pp-store是一个基于Flux架构的轻量级的React状态管理库，它采用**分散式存储**来管理应用的共享状态，并保证状态以一种可预测的方式发生变化，同时基于react hooks特性来为组件提供数据和组件的re-render功能，并且提供了零配置的 Log调试（后续会提供Chrome Extension调试工具实现time-travel）

## 特性：

- 分散式数据源

    pp-store推荐创建多个store来管理不同的模块，各模块之间逻辑分离，有利于开发者更高效的设计store的状态，同时也会拥有更好的性能。

    

- 配置集中化

    我们希望 store 的相关逻辑如 effects、state、reducers 都声明在同一份配置文件中，这样可以很方便的查看当前store的所有逻辑，同时也不用担心文件太大，如果真这样那说明需要再创建一个 store。

    

- 两种开发模式（loose、strict）

    分别对应不同的应用需求，详情见下方[什么情况使用？](#什么情况使用？)

    

- hooks based

    基于 hooks 的创建，所以我们`store`的数据能够很轻松地在组件中获取，而不需要 Context 去进行数据传递。也就是说，不再需要 Provider 去包裹你的 App 程序。

    

- 兼容Class组件

    通过Inject高阶组件来连接组件和store，在props获取store的状态和管理store状态的方法。

## 什么情况使用？

pp-store支持`loose`和`strict`两种模式

- 构造简单状态时，可以设置`mode: 'loose'`开启宽松模式，该模式下我们在创建store时，可以不用声明reducer、effect。此时useStore的用法与useState一致，`const [count, setCount] = useCounterStore()`, 可以直接通过setCount方法来更新store里的状态。
- 构造复杂状态时，我们推荐使用默认的严格模式，该模式下将遵循相关的规范编写代码，这有助于更好的管理组件外的状态。

## 项目结构

```
├── index.html
├── main.js
└── store
    └── cart.js           # 购物车模块
    └── product.js        # 产品模块
```

## 使用流程

### loose mode

1. 创建store

    ```jsx
    // couterStore.js
    import ppStore from 'ppstore';

    const counterStore = ppStore.create({
    	namespace: 'counterStore',
       state: 1,
    });

    export default counterStore; 
    ```
2. 管理store状态

    ```jsx
    // Counter.jsx
    import CounterStore, { useStore as useCounterStore } from 'counterStore';

    export function Counter() {
      const [count, setCount] = useCounterStore();
      return (
        <div>
          <button
            onClick={() => {
              setCount(count + 1);
            }}
          >
            +
          </button>
    			<p>current count: {count}</p>
        </div>
      );
    }
    ```

---

### strict mode

1. 创建store

    ```jsx
    // couterStore.js
    import ppStore from 'ppstore';

    const counterStore = ppStore.create({
      namespace: 'counterStore',
      state: {
        loading: false,
        count: 0
      },

      reducers: {
        INCRMENT(state) {
          return { ...state, count: state.count + 1 }
        },
        SET_COUNT(state, payload) {
          return { ...state, count: payload };
        },
        SET_LOADING(state, payload) {
          return { ...state, loading: payload }
        }
      },

      effects: {
        FETCH_REMOTE_COUNT: payload => async dispatch => {
          dispatch({ type: 'SET_LOADING', payload: true })
          const res = await api();
          dispatch({ type: 'SET_COUNT', res })
          dispatch({ type: 'SET_LOADING', payload: false })
        },
      }
    });

    export default counterStore;
    ```

2. 管理store状态

    ```jsx
    // Counter.jsx
    import CounterStore, { useStore as useCounterStore } from 'counterStore';

    export function Counter() {
      const [count, dispatch] = useCounterStore()

      const incrment = () => dispatch({ type: 'INCRMENT' })
      const getRemoteCount = () => dispatch({ effectType: 'FETCH_REMOTE_COUNT' })
      return (
        <div>
          <button onClick={incrment}>ADD</button>
          <button onClick={getRemoteCount}>获取远程Count</button>

          <p>current count: {count}</p>
        </div>
      );
    }
    ```

## 核心概念

- State：每一个store实例都包含独立的state用来管理状态
- Action：`interface Action { type?: string, effectType?: string, payload?: any }`，修改store中状态的唯一方式就是调用`dispatch(action: Action)`
- Reducer：`type Reducer = <T>(state: T, payload?: any) => T`**同步**的纯函数，用来响应状态的变化，返回值将会作为最新的State
- Effect：`type Effect = (payload?: any) => (dispatch: (action: Action) => void) => void` 用于执行异步操作，内部也会通过调用`dispatch`来改变store的状态


## API Reference

### createStore

- 入参opts对象

    | 属性        | 类型                                                         | 描述                    |
    | ----------- | ------------------------------------------------------------ | ----------------------- |
    | namespace   | string                                                       | 模块的名称              |
    | state       | any                                                          | 状态的初始值            |
    | reducers    | { [type: string]: <T>(state: T, payload?: any) => T }        | 更新store状态的函数对象 |
    | effects     | { [type: string]: (payload?: any) => (dispatch: Dispatch) => void } | 执行异步操作的函数对象  |
    | middlewares | (string \| Middleware)[]                                     | 中间件函数数组          |

- 出参store对象

    | 属性          | 类型                                                         | 描述                              |
    | ------------- | ------------------------------------------------------------ | --------------------------------- |
    | useSelector   | <T>(selector: (state: T)=>T,isEqual:(state: T, newState: T) => boolean) => T | 获取store状态的hook函数           |
    | dispatch      | type Dispatch = (action: Action) => void                     | 派发事件，可以派发Effect或Reducer |
    | subscribe     | (listener: () => void)                                       | 订阅数据更新                      |
    | getShareState | () => any                                                    | 获取store最新状态                 |
    | useStore      | <T>(selector: (state: T)=>T,isEqual:(state: T, newState: T) => boolean) => [T, dispatch: Dispatch] | 获取store状态和dispatch方法       |

    

FAQ：

- [ ]  dispatch和dispatchAction要不要区分
- [ ]  Action概念是否要保留
- [ ]  loose模式下，dispatch函数的调用方式

    ```jsx
    function Child() {
    	// 方式一：
      const [count, setCount] = countStore.useCountStore();
      const handleClick = () => {
        setCount(10);
      }

    	// 方式二：
    	const [count, dispatch] = countStore.useCountStore();
      const handleClick = () => {
        dispatch({ payload: 10 });
      }

      return <p onClick={ handleClick }> { count } </p>
    }
    ```

调研其他状态管理库，对比。 

1. redux的问题？小型项目使用useContext做状态管理的缺点？
   1. 缺少log
2. 为什么不用已有的轮子，我们的库有什么优势？什么是业务场景需要的？
   1. 渐进式
   2. 
3. 确实怎么使用它，是否解决了redux的问题？



阶段：

1. 实验阶段（做好充分的调研）

2. 推进阶段

   

二审TODO:

- [ ] Inject
  - [x] memo（可配置）
  - [ ] 传递Ref（可配置）
  - [ ] context
  - [ ] show displayName

- [ ] log

- [ ] 为什么使用pp-store
- [ ] 实现一个复杂例子做对比
  - [ ] 异步
  - [ ] 多模块



TODO：

1. 轻量的API
2. 业务调研



TODO:

- [ ]  完善log
- [ ]  错误捕获
- [ ]  TypeScript
- [ ] Test集成
- [ ]  完善文档和示例
- [ ]  浏览器插件









- [ ] 

